# LeetCode 977. Squares of a Sorted Array

## 问题描述
给定一个按非递减顺序排序的整数数组 `nums`，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。

示例:
```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
```

## 解法一：暴力解法
```python
class Solution_1:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        result = []
        for num in nums:
            result.append(num * num)
        result.sort()
        return result
```

### 详细思路
1. **平方计算阶段**：
   - 遍历原始数组中的每个元素
   - 计算当前元素的平方值（num * num）
   - 将平方值追加到结果列表中
   - 示例：对于输入[-3, -1, 0, 2, 4]，平方后得到[9, 1, 0, 4, 16]

2. **排序阶段**：
   - 使用内置sort()方法对结果列表进行排序
   - Python的sort()使用Timsort算法，时间复杂度为O(nlogn)
   - 排序后得到[0, 1, 4, 9, 16]

### 复杂度分析
- **时间复杂度**：O(n + nlogn) = O(nlogn)
  - 平方计算：O(n)
  - 排序：O(nlogn)
- **空间复杂度**：O(n)
  - 需要额外空间存储平方结果
  - 排序可能使用O(n)额外空间（Timsort最坏情况）

### 优缺点
优点：
- 实现简单直观
- 代码易于理解和维护

缺点：
- 没有利用输入数组已排序的特性
- 排序操作增加了时间复杂度

### 适用场景
- 当代码可读性比性能更重要时
- 处理小规模数据时
- 作为基准解法用于对比验证

## 解法二：双指针
```python
class Solution_2:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [0] * n
        left = 0
        right = n - 1
        pos = n - 1  # 从结果数组末尾开始填充
        while left <= right:
            left_square = nums[left] * nums[left]
            right_square = nums[right] * nums[right]
            if left_square > right_square:
                result[pos] = left_square
                left += 1  # 左指针右移
            else:
                result[pos] = right_square
                right -= 1  # 右指针左移
            pos -= 1  # 填充位置前移
        return result
```

### 详细思路
1. **初始化阶段**：
   - 创建与输入数组等长的结果数组
   - 设置左指针(left)指向数组开头(0)
   - 设置右指针(right)指向数组末尾(n-1)
   - 设置填充位置(pos)从结果数组末尾开始

2. **遍历比较阶段**：
   - 计算左指针元素的平方(left_square)
   - 计算右指针元素的平方(right_square)
   - 比较两个平方值：
     - 如果left_square更大：将其放入结果数组的pos位置，左指针右移
     - 否则：将right_square放入pos位置，右指针左移
   - pos位置前移
   - 示例：输入[-4,-1,0,3,10]
     - 第一轮：比较(-4)²=16和10²=100 → 放入100
     - 第二轮：比较(-4)²=16和3²=9 → 放入16
     - 第三轮：比较(-1)²=1和3²=9 → 放入9
     - 第四轮：比较(-1)²=1和0²=0 → 放入1
     - 第五轮：比较0²=0 → 放入0
     - 最终结果：[0,1,9,16,100]

3. **终止条件**：
   - 当left > right时循环结束
   - 此时所有元素都已处理完毕

### 复杂度分析
- **时间复杂度**：O(n)
  - 只需一次遍历，每个元素只被访问一次
- **空间复杂度**：O(n)
  - 需要额外空间存储结果
  - 但空间使用是最优的，无法进一步减少

### 关键点
1. 利用输入数组已排序的特性：
   - 数组两端的平方值必定有一个是当前最大值
   - 通过比较两端值可以确定当前最大值

2. 填充顺序：
   - 从结果数组末尾开始填充
   - 确保结果数组有序

3. 指针移动：
   - 每次只移动一个指针（左或右）
   - 确保所有元素都被处理

### 边界情况
1. 全正数数组：[1,2,3]
2. 全负数数组：[-3,-2,-1]
3. 包含零的数组：[-2,0,1]
4. 单元素数组：[0]或[1]或[-1]
5. 空数组：[]

### 优化空间
1. 可以提前终止：
   - 当left和right相遇后剩余元素平方值相同
   - 可以批量填充剩余位置

2. 内存优化：
   - 如果允许修改原数组，可以复用空间
   - 但会破坏输入数据，不推荐

## 两种解法深度对比
| 对比维度 | 暴力解法 | 双指针解法 |
|----------|----------|------------|
| **时间复杂度** | O(nlogn) | O(n) |
| **空间复杂度** | O(n) | O(n) |
| **代码复杂度** | 简单 | 中等 |
| **性能表现** | 较差 | 最优 |
| **内存访问** | 随机访问 | 顺序访问 |
| **缓存友好** | 否 | 是 |
| **适用数据规模** | 小数据(n<1000) | 大数据 |
| **稳定性** | 稳定 | 稳定 |
| **利用输入特性** | 否 | 是 |
| **实际应用** | 原型开发 | 生产环境 |

### 性能测试建议
1. 小数据测试(n=10)：
   - 暴力解法可能更快（常数因子小）
   
2. 大数据测试(n=1,000,000)：
   - 双指针解法明显优势
   - 暴力解法受排序拖累

### 选择建议
1. 选择暴力解法当：
   - 代码可读性更重要
   - 处理小规模数据
   - 快速原型开发

2. 选择双指针解法当：
   - 性能是关键因素
   - 处理大规模数据
   - 需要最优解

## 深入注意事项
1. **输入特性利用**：
   - 双指针解法关键依赖于输入数组的有序性
   - 对于无序数组，必须先排序才能使用此方法

2. **填充方向**：
   - 必须从后往前填充结果数组
   - 如果尝试从前往后填充，无法保证有序性

3. **边界条件**：
   - 空数组输入：直接返回空数组
   - 单元素数组：直接返回其平方
   - 全零数组：结果也是全零
   - 大数情况：注意整数溢出（Python无此问题）

4. **数值范围**：
   - 题目保证输入在[-10^4, 10^4]范围内
   - 平方后最大值为100,000,000，不会溢出32位整数

5. **稳定性**：
   - 当左右平方值相等时，优先取右指针值
   - 这保证了相对顺序的稳定性

6. **调试技巧**：
   - 打印每次循环后的中间状态
   - 特别关注指针移动和结果数组变化

## 扩展类似问题
1. **基础变种**：
   - LeetCode 283. Move Zeroes（移动零）
   - LeetCode 88. Merge Sorted Array（合并有序数组）

2. **进阶问题**：
   - LeetCode 360. Sort Transformed Array（转换后排序）
   - LeetCode 845. Longest Mountain in Array（数组中最长山脉）

3. **多维扩展**：
   - 处理二维矩阵的排序问题
   - 图形学中的距离排序问题

4. **实际应用**：
   - 信号处理中的能量计算
   - 统计学中的方差计算
   - 机器学习中的特征归一化

### 解题模式总结
1. **双指针模式**：
   - 适用于有序数组处理
   - 常用于合并、搜索、比较类问题

2. **平方特性**：
   - 负数平方后顺序反转
   - 可以利用这个特性简化问题

3. **原地操作**：
   - 很多数组问题要求原地操作
   - 需要熟练掌握指针技巧
